require(tidyverse)
require(FactoMineR)
require(dplyr)

load("Base.RData")
table(base$fusion)
dat <- base
summary(dat)

## On vire les variables sur lesquelles il y a trop de donnÃ©es manquantes
manquants <- sapply(dat,function(x) sum(is.na(x))) 
lesquelles <- which(manquants>round(nrow(dat)*0.03,0))
dat <- dat[,-lesquelles]

num  <- select(dat,starts_with("dist"),starts_with("nb")) 
fact <- select(dat,-starts_with("dist"),-starts_with("nb"))

# On remplace les NA par la moyenne et les NaN par le max  
# (c'est quand on a un zÃ©ro et on considÃ¨re la dist comme max dan ces cas)
maxi <- sapply(num, max,na.rm=T)
moy  <- sapply(num, mean,na.rm=T)

for (ii in 1:ncol(num))
{
  num[is.na(num[,ii]),ii] <- moy[ii]
  num[is.nan(num[,ii]),ii] <- maxi[ii]
}

# On refusionne les bases
dat1 <- cbind(fact,num)

#On met en facteur la variable de fusion
dat1$fusion<-as.factor(dat1$fusion)

#Visualisation des boxplots pour les vars dist en fonction de la fusion
library(ggplot2)

ggplot(dat1,aes(x=fusion,y=dist_P13_POP))+geom_violin()+geom_boxplot(width=0.1)
ggplot(dat1,aes(x=fusion,y=dist_Pol1))+geom_violin()+geom_boxplot(width=0.1)

ggplot(dat1,aes(x=fusion,y=log(nb_navettes)))+geom_violin()+geom_boxplot(width=0.1)

#On visualise les corrélations sur les variables de distance 
install.packages("corrplot")
library(corrplot)
mat_cor<-select(dat1,starts_with("nb"),starts_with("dist"))
class(mat_cor)

dat1_cor<-round(cor(mat_cor),2)

#corrplot(dat1_cor, method = "circle")
#corrplot(dat1_cor, method = "ellipse")
#corrplot(dat1_cor, method = "number")
corrplot(dat1_cor, method = "pie")

#K means
#attention, il faut réduire et centrer qd les variables sont dans des unités différentes
#on fait sur les données de l'ACP
claskmeans<-kmeans(mat_cor,centers=10000)

table(claskmeans$cluster)
classk<-as.factor(claskmeans$cluster)
cbind.data.frame(spam_final,classk)

claskmeans<-kmeans(res.pcabis$ind$coord,centers=2)
table(claskmeans$cluster)
classk<-as.factor(claskmeans$cluster)
spam_final1<-cbind.data.frame(spam_final,classk)
table(spam_final1$X1,spam_final1$classk)



##ACP pour description rapide
#dat <- cbind(fact,num) %>% 
#  mutate(y=as.factor(fusion)) %>%
#  select(-ident,-first,-second,-starts_with("fusion"))
#row.names(dat) <- fact$ident

#acp <- PCA(dat,quali.sup = c(1:8,39),graph = F)
#plot.PCA(acp,choix="var",col.var="blue")
#plot.PCA(acp,choix=c("ind"),select = "contrib20")

#baseML <- dat

save(base,baseML,mapCom,couples,file="Base.RData")




#Creation de plusieurs bases pour traiter le faible nombre de fusions
#en dupliquant les fusions et en les bruitants
#base_fusion <- filter(dat,fusion==1)
#base_fusion<-dat[dat$fusion==1, ]

#coli <- which(colnames(base_fusion) %in% colnames(select(base_fusion,starts_with("dist"))))
#base_fusion_bis <- base_fusion

#for (ii in coli)
#{
#  a<-mean(base_fusion[,ii],is.na=F)
#  b<-var(base_fusion[,ii],na.rm=TRUE)
#  base_fusion_bis[,ii]<-base_fusion[,ii]+rnorm(1, a,b)
#  print(ii)
#}

#coli <- which(colnames(base_fusion_bis) %in% colnames(select(base_fusion_bis,starts_with("nb"))))

#for (ii in coli)
#{
#  a<-mean(base_fusion_bis[,ii],is.na=F)
#  b<-var(base_fusion_bis[,ii],na.rm=TRUE)
#  base_fusion_ter[,ii]<-base_fusion_bis[,ii]+rnorm(1, a,b)
#  print(ii)
#}







